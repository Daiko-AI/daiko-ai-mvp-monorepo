import { inngest } from "@daiko-ai/shared";
// import { events } from "../events"; // Remove this import
import { initProposalGeneratorGraph } from "@daiko-ai/proposal-generator";
import type { ProposalInsert } from "@daiko-ai/shared";
import { db, proposalTable, signalsTable } from "@daiko-ai/shared";
import { eq } from "drizzle-orm"; // Import eq for querying
import { Logger, LogLevel } from "@daiko-ai/shared"; // Import Logger class and LogLevel

// Create a logger instance for this workflow
const logger = new Logger({ level: LogLevel.INFO });

export const generateProposal = inngest.createFunction(
  { id: "generate-proposal" },
  { event: "processing/signal.detected" },
  async ({ event, step }) => {
    // Add step to async function arguments
    const { signalId } = event.data;

    // Step 1: Fetch full signal data from DB using signalId
    const signalData = await step.run("fetch-signal-data", async () => {
      const signal = await db.query.signalsTable.findFirst({
        where: eq(signalsTable.id, signalId),
        // Add with: { ... } if relations are needed
      });
      if (!signal) {
        throw new Error(`Signal with ID ${signalId} not found.`);
      }
      return signal;
    });

    // Re-add date conversion for DB data
    const processedSignalData = {
      ...signalData,
      createdAt: new Date(signalData.createdAt),
      updatedAt: new Date(signalData.updatedAt),
      timestamp: new Date(signalData.timestamp),
      expiresAt: signalData.expiresAt ? new Date(signalData.expiresAt) : new Date(0), // Use default if null
    };

    // Step 2: Initialize agent graph (moved outside step.run)
    // Graph object is complex and likely not serializable/recoverable via step.run
    const { graph, config } = await initProposalGeneratorGraph(signalId);

    if (!graph || !config) {
      throw new Error("Agent initialization failed.");
    }

    // Step 3: Execute agent to generate proposal
    const runResult = await step.run("invoke-agent-graph", async () => {
      const inputForGraph = {
        signalData: processedSignalData, // Use processed data with Date objects
        // Other initial states for the graph if necessary
        messages: [],
      };
      // Temporary cast to any to bypass type error - investigate proposal-generator types
      return graph.invoke(inputForGraph, config);
    });

    const proposal = runResult.proposal;
    if (!proposal) {
      throw new Error("No proposal generated");
    }

    // Step 4: Persist proposal to DB
    const insertedProposals = await step.run("save-proposal", async () => {
      const insertData: ProposalInsert = {
        // id is generated by DB
        triggerEventId: event.id,
        // userId: fullSignalData.userId, // Reverted: userId not found in signalData type, set to null for now
        userId: null, // TODO: Confirm where to get userId from
        // signalId: signalId, // Commented out: Add signalId to proposals schema first
        title: proposal.title,
        summary: proposal.summary,
        reason: proposal.reason,
        sources: proposal.sources,
        type: proposal.type,
        proposedBy: proposal.proposedBy,
        financialImpact: proposal.financialImpact,
        expires_at: proposal.expires_at ? new Date(proposal.expires_at) : new Date(), // Convert/default Date
        status: proposal.status ?? "active",
        contractCall: proposal.contractCall,
      };
      // Drizzle returns the inserted row(s)
      const result = await db.insert(proposalTable).values(insertData).returning();
      // Ensure result is an array, even if only one row is inserted
      return Array.isArray(result) ? result : [result];
    });

    // Check if any proposals were actually inserted
    if (!insertedProposals || insertedProposals.length === 0) {
      // Throw an error or return if saving failed or returned empty
      // Logging the attempt might be useful
      logger.error("save-proposal", "Failed to save proposal or retrieve saved proposal.");
      throw new Error("Failed to save proposal or retrieve saved proposal.");
    }

    // Step 5: Emit proposal.created event for each inserted proposal
    await step.run("send-proposal-created-events", async () => {
      // Map over the array of (potentially serialized) proposals

      // Construct the payload for a single proposal event
      return inngest.send({
        name: "notification/proposal.created",
        data: {
          proposals: insertedProposals,
        },
      });
    });

    // Return success, potentially with the ID of the first proposal
    // Use non-null assertion as the check above guarantees the array is not empty here
    return { success: true, proposalId: insertedProposals[0]!.id };
  },
);
